use bevy::{prelude::Vec2, render::primitives::Aabb};

use crate::{point_bin_grid::PointBinGrid, triangle_set::{DelaunayTriangleSet, Triangle2D, DelaunayTriangle}};

/// Encapsulates the entire constrained Delaunay triangulation algorithm, according to S. W. Sloan's proposal, and stores the resulting triangulation.
/// Instantiate this struct and call triangulate to obtain the triangulation of a point cloud.
pub struct DelaunayTriangulation {
    // The bin grid used for optimizing the search of triangles that contain a points
    grid: PointBinGrid,

    // The metadata of all the generated triangles
    // TODO Make this a ressource
    triangle_set: Option<DelaunayTriangleSet>,

    // The stack of adjacent triangles, used when checking for the Delaunay constraint
    adjacent_triangles: Option<Vec<usize>>,

    // A stack, parallel to the adjacent triangles stack, that contains the local index [0, 2] of the edge shared among the adjacent triangle
    // of the other stack and the triangle that was processed before it
    adjacent_triangle_edges: Vec<usize>,

    // The list of triangles to be discarded (holes and supertriangle)
    // TODO make this a ressource
    triangles_to_remove: Option<Vec<usize>>,

    // The bounding box of the main point cloud
    // TODO make this a ressource
    main_point_cloud_bounds: Aabb,
}

impl DelaunayTriangulation {
    /// Gets the metadata of all the generated triangles.
    pub fn triangle_set(&self) -> &Option<DelaunayTriangleSet> {
        &self.triangle_set
    }

    /// Gets the triangles generated by the triangulate method that should be discarded, those that are inside holes or exclusively belong to the supertriangle.
    pub fn discarded_triangles(&self) -> &Vec<usize> {
        &self.triangles_to_remove
    }

    /// Generates the triangulation of a point cloud that fulfills the Delaunay constraint. It allows the creation of holes in the
    /// triangulation, formed by closed polygons that do not overlap each other.
    ///
    /// # Arguments
    ///
    /// * `inputPoints` - The main point cloud. It must contain, at least, 3 points.
    /// * `maximumAreaTesselation` - Optional. When it is greater than zero, all the triangles of the main point cloud will be tessellated until none of them occupies
    /// an area greater than this value.
    /// * `constrainedEdges` - Optional. The list of holes. Each hole must be defined by a closed polygon formed by consecutive points sorted counter-clockwise.
    /// It does not matter if the polugons are convex or concave. It is preferable that holes lay inside the main point cloud.
    pub fn triangulate(
        &self,
        input_points: &Vec<Vec2>,
        maximum_area_tesselation: f32,
        constrained_edges: Option<&Vec<Vec<Vec2>>>,
    ) {
        // Initialize containers
        if let Some(mut triangle_set) = self.triangle_set {
            triangle_set.clear();
            triangle_set.set_capacity(input_points.len() - 2);
        } else {
            self.triangle_set = Some(DelaunayTriangleSet::new(input_points.len() - 2));
        }

        if let Some(adjacent_triangles) = self.adjacent_triangles {
            self.adjacent_triangles = Some(Vec::<usize>::with_capacity(input_points.len() - 2));
            self.adjacent_triangle_edges = Vec::<usize>::with_capacity(input_points.len() - 2);
        } else {
            if let Some(mut adjacent_triangles) = self.adjacent_triangles {
                adjacent_triangles.clear();
            }
            self.adjacent_triangle_edges.clear();
        }

        if let Some(mut triangles_to_remove) = self.triangles_to_remove {
            triangles_to_remove.clear();
        } else {
            self.triangles_to_remove = Some(Vec::<usize>::new());
        }

            // 1: Normalization
        self.main_point_cloud_bounds =
            calculate_bounds_with_left_bottom_corner_at_origin(&input_points);

        let mut normalized_points = input_points.clone();
        normalize_points(&mut normalized_points, &self.main_point_cloud_bounds);

            // 2: Addition of points to the space partitioning grid
        let normalized_cloud_bounds =
            calculate_bounds_with_left_bottom_corner_at_origin(&normalized_points);
        let grid = PointBinGrid::new(
            (input_points.len() as f32).sqrt().sqrt().ceil() as usize,
            normalized_cloud_bounds.size(),
        );

        for point in normalized_points {
            grid.add_point(point);
        }

            // 3: Supertriangle initialization
        let supertriangle = Triangle2D::new(
            Vec2::new(-100.0, -100.0),
            Vec2::new(100.0, -100.0),
            Vec2::new(0.0, 100.0),
        );
        self.triangle_set.unwrap().add_triangle_from_points(
            supertriangle.p0,
            supertriangle.p1,
            supertriangle.p2,
            None,
            None,
            None,
        );

            // 4: Adding points to the Triangle set and Triangulation
            // Points are added one at a time, and points that are close together are inserted together because they are sorted in the grid, 
            // so a later step for finding their containing triangle is faster
        for cell in grid.cells.iter() {
                for point in cell {
                    // All the points in the bin are added together, one by one
                    add_point_to_triangulation(point);
                }
        }

        if maximum_area_tesselation > 0.0 {
            tesselate(maximum_area_tesselation);
        }

            // 5: Holes creation (constrained edges)
        if let Some(constrained_edges) = constrained_edges {
                // Adds the points of all the polygons to the triangulation
            let mut constrained_edge_indices = Vec::new();

            for constrained_edge in constrained_edges {
                    // 5.1: Normalize
                let mut normalized_constrained_edges = constrained_edge.clone();
                normalize_points(&mut normalized_constrained_edges, &self.main_point_cloud_bounds);

                let mut polygon_edge_indices = Vec::new();

                for i in 0..normalized_constrained_edges.len() {
                    // 5.2: Add the points to the Triangle set
                    if normalized_constrained_edges[i]
                        == normalized_constrained_edges
                            [(i + 1) % normalized_constrained_edges.len()]
                    {
                        println!("The list of constrained edges contains a zero-length edge (2 consecutive coinciding points, indices {} and {}). It will be ignored.", i, (i + 1) % normalized_constrained_edges.len());
                        continue;
                    }

                    let added_point_index =
                        add_point_to_triangulation(normalized_constrained_edges[i]);
                    polygon_edge_indices.push(added_point_index);
                }

                constrained_edge_indices.push(polygon_edge_indices);
            }

            for constrained_edge in constrained_edge_indices {
                // 5.3: Create the constrained edges
                for i in 0..constrained_edge.len() {
                    add_constrained_edge_to_triangulation(
                        constrained_edge[i],
                        constrained_edge[(i + 1) % constrained_edge.len()],
                    );
                }
            }

                // 5.4: Identify all the triangles in the polygon
            for constrained_edge in constrained_edge_indices {
                m_triangle_set
                    .get_triangles_in_polygon(&constrained_edge, &mut self.triangles_to_remove);
            }
        }

        get_supertriangle_triangles(&mut self.triangles_to_remove);

        self.triangles_to_remove.unwrap().sort();

        denormalize_points(&mut self.triangle_set.unwrap().points, &self.main_point_cloud_bounds);
    }

/// Reads the triangles generated by the Triangulate method, discarding all those triangles that are inside a hole or belong to the supertriangle.
/// 
/// # Arguments
/// 
/// * `outputTriangles` - The list to which the triangles will be added. No elements will be removed from this list.
pub fn get_triangles_discarding_holes(&self, output_triangles: &mut Vec<Triangle2D>) {
    if output_triangles.capacity() < self.triangle_set.unwrap().triangle_count() {
        output_triangles.reserve(self.triangle_set.unwrap().triangle_count() - output_triangles.capacity());
    }

    // Output filtering
    for i in 0..self.triangle_set.unwrap().triangle_count() {
        let mut is_triangle_to_be_removed = false;

        // Is the triangle in the "To Remove" list?
        for j in 0..self.triangles_to_remove.unwrap().len() {
            if self.triangles_to_remove.unwrap()[j] >= i {
                is_triangle_to_be_removed = self.triangles_to_remove.unwrap()[j] == i;
                break;
            }
        }

        if !is_triangle_to_be_removed {
            let triangle = self.triangle_set.unwrap().get_triangle(i);
            output_triangles.push(Triangle2D::new(self.triangle_set.unwrap().points[triangle.p[0]], self.triangle_set.unwrap().points[triangle.p[1]], self.triangle_set.unwrap().points[triangle.p[2]]));
        }
    }
}

/// Reads all the triangles generated by the Triangulate method, without discarding any.
/// 
/// # Arguments
/// 
/// * `output_triangles` - The list to which the triangles will be added. No elements will be removed from this list.
pub fn get_all_triangles(&self, output_triangles: &mut Vec<Triangle2D>) {
    if output_triangles.capacity() < self.triangle_set.unwrap().triangle_count() {
        output_triangles.reserve(self.triangle_set.unwrap().triangle_count() - output_triangles.capacity());
    }

    for i in 0..self.triangle_set.unwrap().triangle_count() {
        let triangle = self.triangle_set.unwrap().get_triangle(i);
        output_triangles.push(Triangle2D::new(
            self.triangle_set.unwrap().points[triangle.p[0]],
            self.triangle_set.unwrap().points[triangle.p[1]],
            self.triangle_set.unwrap().points[triangle.p[2]],
        ));
    }
}

/// Adds a point to the triangulation, which implies splitting a triangle into 3 pieces and checking that all triangles still fulfill the Delaunay constraint.
/// If the point coincides in space with an existing point, nothing will be done and the index of the existing point will be returned.
/// 
/// # Arguments
///
/// * `pointToInsert` - The point to add to the triangulation.
///
/// # Returns
///
/// The index of the new point in the triangle set.
fn add_point_to_triangulation(&self, point_to_insert: Vec2) -> Option<usize> {
            // Note: Adjacent triangle, opposite to the inserted point, is always at index 1
            // Note 2: Adjacent triangles are stored CCW automatically, their index matches the index of the first vertex in every edge, and it is known that vertices are stored CCW
            if let Some(triangle_set) = self.triangle_set{

            // 4.1: Check point existence
            let existing_point_index = triangle_set.get_index_of_point(point_to_insert);

            if let Some(index) = existing_point_index
            {
                return Some(index);
            }

            // 4.2: Search containing triangle
// Start at the last added triangle
            let containing_triangle_index = triangle_set.find_triangle_that_contains_point(point_to_insert, triangle_set.triangle_count()-1);
            let containing_triangle = triangle_set.get_triangle(containing_triangle_index);

            // 4.3: Store the point
            // Inserting a new point into a triangle splits it into 3 pieces, 3 new triangles
            let inserted_point = triangle_set.add_point(point_to_insert);

            // 4.4: Create 2 triangles
            let first_triangle = DelaunayTriangle::new(inserted_point, containing_triangle.p(0), containing_triangle.p(1));
            first_triangle.adjacent(0) = None;
            first_triangle.adjacent(1) = containing_triangle.adjacent(0);
            first_triangle.adjacent(2) = containing_triangle_index;
            first_triangle_index = triangle_set.add_triangle(first_triangle);

            let second_triangle = DelaunayTriangle::new(inserted_point, containing_triangle.p(2), containing_triangle.p(0));
            second_triangle.adjacent(0) = containing_triangle_index;
            second_triangle.adjacent(1) = containing_triangle.adjacent(2);
            second_triangle.adjacent(2) = None;
            second_triangle_index = triangle_set.add_triangle(second_triangle);

            // Sets adjacency between the 2 new triangles
            first_triangle.adjacent(0) = second_triangle_index;
            first_triangle.adjacent(2) = first_triangle_index;
            triangle_set.set_triangle_adjacency(first_triangle_index, &first_triangle.adjacent)
            triangle_set.set_triangle_adjacency(second_triangle_index, &second_triangle.adjacent)

            // Sets the adjacency of the triangles that were adjacent to the original containing triangle
            if let Some(adjacent_triangle) = first_triangle.adjacent(1){
                triangle_set.replace_adjacent(adjacent_triangle, Some(containing_triangle_index), first_triangle_index)
            }
            if let Some(adjacent_triangle) = second_triangle.adjacent(1){
                triangle_set.replace_adjacent(adjacent_triangle, Some(containing_triangle_index), second_triangle_index)
            }

            // 4.5: Transform containing triangle into the third
            // Original triangle is transformed into the third triangle after the point has split the containing triangle into 3
            containingTriangle.p[0] = insertedPoint;
            containingTriangle.adjacent[0] = triangle1Index;
            containingTriangle.adjacent[2] = triangle2Index;
            m_triangleSet.ReplaceTriangle(containingTriangleIndex, containingTriangle);

            // 4.6: Add new triangles to a stack
            // Triangles that contain the inserted point are added to the stack for them to be processed by the Delaunay swapping algorithm
            if(containingTriangle.adjacent[1] != NO_ADJACENT_TRIANGLE) // If they do not have an opposite triangle in the outter edge, there is no need to check the Delaunay constraint for it
            {
                m_adjacentTriangleStack.Push(containingTriangleIndex);
                m_adjacentTriangleEdgeStack.Push(1);
            }

            if(newTriangle1.adjacent[1] != NO_ADJACENT_TRIANGLE)
            {
                m_adjacentTriangleStack.Push(triangle1Index);
                m_adjacentTriangleEdgeStack.Push(1);
            }

            if (newTriangle2.adjacent[1] != NO_ADJACENT_TRIANGLE)
            {
                m_adjacentTriangleStack.Push(triangle2Index);
                m_adjacentTriangleEdgeStack.Push(1);
            }

            // 4.7: Check Delaunay constraint
            FulfillDelaunayConstraint(m_adjacentTriangleStack, m_adjacentTriangleEdgeStack);

            return insertedPoint;
        }

}
