use bevy::{render::primitives::Aabb, prelude::Vec2};

use crate::{point_bin_grid::PointBinGrid, triangle_set::{DelaunayTriangleSet, Triangle2D, DelaunayTriangle, DelaunayTriangleEdge, Edge}, math_utils};

/// Encapsulates the entire constrained Delaunay triangulation algorithm, according to S. W. Sloan's proposal, and stores the resulting triangulation.
/// Instantiate this struct and call triangulate to obtain the triangulation of a point cloud.
pub struct DelaunayTriangulation {
    // The bin grid used for optimizing the search of triangles that contain a points
    grid: PointBinGrid,

    // The metadata of all the generated triangles
    // TODO Make this a ressource
    triangle_set: Option<DelaunayTriangleSet>,

    // The stack of adjacent triangles, used when checking for the Delaunay constraint
    adjacent_triangles: Option<Vec<usize>>,

    // A stack, parallel to the adjacent triangles stack, that contains the local index [0, 2] of the edge shared among the adjacent triangle
    // of the other stack and the triangle that was processed before it
    adjacent_triangle_edges: Vec<usize>,

    // The list of triangles to be discarded (holes and supertriangle)
    // TODO make this a ressource
    triangles_to_remove: Option<Vec<usize>>,

    // The bounding box of the main point cloud
    // TODO make this a ressource
    main_point_cloud_bounds: Aabb,
}

impl DelaunayTriangulation {
    /// Gets the metadata of all the generated triangles.
    pub fn triangle_set(&self) -> &Option<DelaunayTriangleSet> {
        &self.triangle_set
    }

    /// Gets the triangles generated by the triangulate method that should be discarded, those that are inside holes or exclusively belong to the supertriangle.
    pub fn discarded_triangles(&self) -> Option<&Vec<usize>> {
        match &self.triangles_to_remove{
            Some(triangles) =>return Some(triangles),
            None => None,
        }
    }

    /// Generates the triangulation of a point cloud that fulfills the Delaunay constraint. It allows the creation of holes in the
    /// triangulation, formed by closed polygons that do not overlap each other.
    ///
    /// # Arguments
    ///
    /// * `inputPoints` - The main point cloud. It must contain, at least, 3 points.
    /// * `maximumAreaTesselation` - Optional. When it is greater than zero, all the triangles of the main point cloud will be tessellated until none of them occupies
    /// an area greater than this value.
    /// * `constrainedEdges` - Optional. The list of holes. Each hole must be defined by a closed polygon formed by consecutive points sorted counter-clockwise.
    /// It does not matter if the polugons are convex or concave. It is preferable that holes lay inside the main point cloud.
    pub fn triangulate(
        &self,
        input_points: &Vec<Vec2>,
        maximum_area_tesselation: f32,
        constrained_edges: Option<&Vec<Vec<Vec2>>>,
    ) {
        // Initialize containers
        if let Some(mut triangle_set) = self.triangle_set {
            triangle_set.clear();
            triangle_set.set_capacity(input_points.len() - 2);
        } else {
            self.triangle_set = Some(DelaunayTriangleSet::new(input_points.len() - 2));
        }

        if let Some(adjacent_triangles) = self.adjacent_triangles {
            self.adjacent_triangles = Some(Vec::<usize>::with_capacity(input_points.len() - 2));
            self.adjacent_triangle_edges = Vec::<usize>::with_capacity(input_points.len() - 2);
        } else {
            if let Some(mut adjacent_triangles) = self.adjacent_triangles {
                adjacent_triangles.clear();
            }
            self.adjacent_triangle_edges.clear();
        }

        if let Some(mut triangles_to_remove) = self.triangles_to_remove {
            triangles_to_remove.clear();
        } else {
            self.triangles_to_remove = Some(Vec::<usize>::new());
        }

            // 1: Normalization
        self.main_point_cloud_bounds =
            calculate_bounds_with_left_bottom_corner_at_origin(&input_points);

        let mut normalized_points = input_points.clone();
        normalize_points(&mut normalized_points, &self.main_point_cloud_bounds);

            // 2: Addition of points to the space partitioning grid
        let normalized_cloud_bounds =
            calculate_bounds_with_left_bottom_corner_at_origin(&normalized_points);
        let grid = PointBinGrid::new(
            (input_points.len() as f32).sqrt().sqrt().ceil() as usize,
            normalized_cloud_bounds.size(),
        );

        for point in normalized_points {
            grid.add_point(point);
        }

            // 3: Supertriangle initialization
        let supertriangle = Triangle2D::new(
            Vec2::new(-100.0, -100.0),
            Vec2::new(100.0, -100.0),
            Vec2::new(0.0, 100.0),
        );
        self.triangle_set.unwrap().add_triangle_from_points(
            supertriangle.p0,
            supertriangle.p1,
            supertriangle.p2,
            None,
            None,
            None,
        );

            // 4: Adding points to the Triangle set and Triangulation
            // Points are added one at a time, and points that are close together are inserted together because they are sorted in the grid, 
            // so a later step for finding their containing triangle is faster
        for cell in grid.cells.iter() {
                for point in cell {
                    // All the points in the bin are added together, one by one
                    add_point_to_triangulation(point);
                }
        }

        if maximum_area_tesselation > 0.0 {
            tesselate(maximum_area_tesselation);
        }

            // 5: Holes creation (constrained edges)
        if let Some(constrained_edges) = constrained_edges {
                // Adds the points of all the polygons to the triangulation
            let mut constrained_edge_indices = Vec::new();

            for constrained_edge in constrained_edges {
                    // 5.1: Normalize
                let mut normalized_constrained_edges = constrained_edge.clone();
                normalize_points(&mut normalized_constrained_edges, &self.main_point_cloud_bounds);

                let mut polygon_edge_indices = Vec::new();

                for i in 0..normalized_constrained_edges.len() {
                    // 5.2: Add the points to the Triangle set
                    if normalized_constrained_edges[i]
                        == normalized_constrained_edges
                            [(i + 1) % normalized_constrained_edges.len()]
                    {
                        println!("The list of constrained edges contains a zero-length edge (2 consecutive coinciding points, indices {} and {}). It will be ignored.", i, (i + 1) % normalized_constrained_edges.len());
                        continue;
                    }

                    let added_point_index =
                        add_point_to_triangulation(normalized_constrained_edges[i]);
                    polygon_edge_indices.push(added_point_index);
                }

                constrained_edge_indices.push(polygon_edge_indices);
            }

            for constrained_edge in constrained_edge_indices {
                // 5.3: Create the constrained edges
                for i in 0..constrained_edge.len() {
                    add_constrained_edge_to_triangulation(
                        constrained_edge[i],
                        constrained_edge[(i + 1) % constrained_edge.len()],
                    );
                }
            }

                // 5.4: Identify all the triangles in the polygon
            for constrained_edge in constrained_edge_indices {
                self.triangle_set.unwrap()
                    .get_triangles_in_polygon(&constrained_edge, &mut self.triangles_to_remove);
            }
        }

        get_supertriangle_triangles(&mut self.triangles_to_remove);

        self.triangles_to_remove.unwrap().sort();

        denormalize_points(&mut self.triangle_set.unwrap().points, &self.main_point_cloud_bounds);
    }

/// Reads the triangles generated by the Triangulate method, discarding all those triangles that are inside a hole or belong to the supertriangle.
/// 
/// # Arguments
/// 
/// * `outputTriangles` - The list to which the triangles will be added. No elements will be removed from this list.
pub fn get_triangles_discarding_holes(&self, output_triangles: &mut Vec<Triangle2D>) {
    if output_triangles.capacity() < self.triangle_set.unwrap().triangle_count() {
        output_triangles.reserve(self.triangle_set.unwrap().triangle_count() - output_triangles.capacity());
    }

    // Output filtering
    for i in 0..self.triangle_set.unwrap().triangle_count() {
        let mut is_triangle_to_be_removed = false;

        // Is the triangle in the "To Remove" list?
        for j in 0..self.triangles_to_remove.unwrap().len() {
            if self.triangles_to_remove.unwrap()[j] >= i {
                is_triangle_to_be_removed = self.triangles_to_remove.unwrap()[j] == i;
                break;
            }
        }

        if !is_triangle_to_be_removed {
            let triangle = self.triangle_set.unwrap().get_triangle(i);
            output_triangles.push(Triangle2D::new(self.triangle_set.unwrap().points[triangle.p[0]], self.triangle_set.unwrap().points[triangle.p[1]], self.triangle_set.unwrap().points[triangle.p[2]]));
        }
    }
}

/// Reads all the triangles generated by the Triangulate method, without discarding any.
/// 
/// # Arguments
/// 
/// * `output_triangles` - The list to which the triangles will be added. No elements will be removed from this list.
pub fn get_all_triangles(&self, output_triangles: &mut Vec<Triangle2D>) {
    if output_triangles.capacity() < self.triangle_set.unwrap().triangle_count() {
        output_triangles.reserve(self.triangle_set.unwrap().triangle_count() - output_triangles.capacity());
    }

    for i in 0..self.triangle_set.unwrap().triangle_count() {
        let triangle = self.triangle_set.unwrap().get_triangle(i);
        output_triangles.push(Triangle2D::new(
            self.triangle_set.unwrap().points[triangle.p[0]],
            self.triangle_set.unwrap().points[triangle.p[1]],
            self.triangle_set.unwrap().points[triangle.p[2]],
        ));
    }
}

/// Adds a point to the triangulation, which implies splitting a triangle into 3 pieces and checking that all triangles still fulfill the Delaunay constraint.
/// If the point coincides in space with an existing point, nothing will be done and the index of the existing point will be returned.
/// 
/// # Arguments
///
/// * `pointToInsert` - The point to add to the triangulation.
///
/// # Returns
///
/// The index of the new point in the triangle set.
fn add_point_to_triangulation(&self, point_to_insert: Vec2) -> Option<usize> {
            let adjacent_triangles = self.adjacent_triangles.expect("adjacent triangles should be initialized.") 
            // Note: Adjacent triangle, opposite to the inserted point, is always at index 1
            // Note 2: Adjacent triangles are stored CCW automatically, their index matches the index of the first vertex in every edge, and it is known that vertices are stored CCW
            if let Some(triangle_set) = self.triangle_set{

            // 4.1: Check point existence
            let existing_point_index = triangle_set.get_index_of_point(point_to_insert);

            if let Some(index) = existing_point_index
            {
                return Some(index);
            }

            // 4.2: Search containing triangle
// Start at the last added triangle
            let containing_triangle_index = triangle_set.find_triangle_that_contains_point(point_to_insert, triangle_set.triangle_count()-1);
            let containing_triangle = triangle_set.get_triangle(containing_triangle_index);

            // 4.3: Store the point
            // Inserting a new point into a triangle splits it into 3 pieces, 3 new triangles
            let inserted_point = triangle_set.add_point(point_to_insert);

            // 4.4: Create 2 triangles
            let first_triangle = DelaunayTriangle::new(inserted_point, containing_triangle.p(0), containing_triangle.p(1));
            first_triangle.adjacent[0] = None;
            first_triangle.adjacent[1] = containing_triangle.adjacent[0];
            first_triangle.adjacent[2] = Some(containing_triangle_index);
            let first_triangle_index = triangle_set.add_triangle(first_triangle);

            let second_triangle = DelaunayTriangle::new(inserted_point, containing_triangle.p(2), containing_triangle.p(0));
            second_triangle.adjacent[0] = Some(containing_triangle_index);
            second_triangle.adjacent[1] = containing_triangle.adjacent[2];
            second_triangle.adjacent[2] = None;
            let second_triangle_index = triangle_set.add_triangle(second_triangle);

            // Sets adjacency between the 2 new triangles
            first_triangle.adjacent[0] = Some(second_triangle_index);
            first_triangle.adjacent[2] = Some(first_triangle_index);
            triangle_set.set_triangle_adjacency(first_triangle_index, &first_triangle.adjacent);
            triangle_set.set_triangle_adjacency(second_triangle_index, &second_triangle.adjacent);

            // Sets the adjacency of the triangles that were adjacent to the original containing triangle
            if let Some(adjacent_triangle) = first_triangle.adjacent[1]{
                triangle_set.replace_adjacent(adjacent_triangle, Some(containing_triangle_index), first_triangle_index)
            }
            if let Some(adjacent_triangle) = second_triangle.adjacent[1]{
                triangle_set.replace_adjacent(adjacent_triangle, Some(containing_triangle_index), second_triangle_index)
            }

            // 4.5: Transform containing triangle into the third
            // Original triangle is transformed into the third triangle after the point has split the containing triangle into 3
            containing_triangle.p[0] = inserted_point;
            containing_triangle.adjacent[0] = Some(first_triangle_index);
            containing_triangle.adjacent[2] = Some(second_triangle_index);
            triangle_set.replace_triangle(containing_triangle_index, containing_triangle);

            // 4.6: Add new triangles to a stack
            // Triangles that contain the inserted point are added to the stack for them to be processed by the Delaunay swapping algorithm
            if let Some(_) = containing_triangle.adjacent[1]{

                adjacent_triangles.push(containing_triangle_index);
                self.adjacent_triangle_edges.push(1);
            }

            if let Some(_) = first_triangle.adjacent[1]{
                adjacent_triangles.push(first_triangle);
                self.adjacent_triangle_edges.push(1);
            }

            if let Some(_) = second_triangle.adjacent[1]{
                adjacent_triangles.push(second_triangle);
                self.adjacent_triangle_edges.push(1);
            }
            // 4.7: Check Delaunay constraint
            fullfill_delaunay_constraint(self.adjacent_triangles, self.adjacent_triangle_edges);

            return Some(inserted_point);
        } else {
            return None;
        }
        }

/// Process a stack of triangles checking whether they fulfill the Delaunay constraint with respect to their adjacents, swapping edges if they do not.
/// The adjacent triangles of the processed triangles are added to the stack too, so the check propagates until they all fulfill the condition.
/// 
/// Parameters:
/// - adjacent_triangles_to_process: Initial set of triangles to check.
/// - adjacent_triangle_edges: The local index (0 to 2) of the edges shared among the triangles in adjacent_triangles_to_process and the triangles that preceded
/// them at the moment they were added. There is one edge per triangle.
fn fulfill_delaunay_constraint(&self, adjacent_triangles_to_process: &mut Vec<usize>, adjacent_triangle_edges: &mut Vec<usize>) {
    let triangle_set = self.triangle_set.expect("The triangle set should not be empty.");

            while adjacent_triangles_to_process.len() > 0
            {
                let current_triangle_to_swap = adjacent_triangles_to_process.pop().expect("Since we checked for the triangles to process before, there should be some here");
                let triangle = triangle_set.get_triangle(current_triangle_to_swap);

                let opposite_triangle_index  = adjacent_triangle_edges.pop().expect("Every triangle should have an adjacent triangle");

                if triangle.adjacent[opposite_triangle_index].is_none(){
                    continue;
                }

                let not_in_edge_vertex_index = (opposite_triangle_index + 2) % 3;
                let triangle_not_in_edge_vertex = triangle_set.get_point_by_index(triangle.p[not_in_edge_vertex_index]);

                let opposite_triangle = triangle_set.get_triangle(triangle.adjacent.[opposite_triangle_index].unwrap());
                let opposite_triangle_points = triangle_set.get_triangle_points(triangle.adjacent[opposite_triangle_index].unwrap());

                if math_utils::is_point_inside_circumcircle(opposite_triangle_points.p0, opposite_triangle_points.p1, opposite_triangle_points.p2, triangle_not_in_edge_vertex)
                {
                    // Finds the edge of the opposite triangle that is shared with the other triangle, this edge will be swapped
                    let shared_edge_vertex_index = self.get_shared_edge(opposite_triangle, current_triangle_to_swap);

                    // Adds the 2 triangles that were adjacent to the opposite triangle, to be processed too
                    if let Some(adjacent) = opposite_triangle.adjacent[(shared_edge_vertex_index + 1) & 3] {
                        let opposite_adjacent0 = adjacent.clone();
                        if !adjacent_triangles_to_process.contains(opposite_adjacent0){
                        adjacent_triangles_to_process.push(opposite_adjacent0);
                        let neighbor_edge = self.get_shared_edge(triangle_set.get_triangle(opposite_adjacent0), triangle.adjacent[opposite_triangle_index].unwrap());
                        adjacent_triangle_edges.push(neighbor_edge);
                        }
                        if !adjacent_triangles_to_process.contains(opposite_adjacent0)
                    }

                    if let Some(adjacent) = opposite_triangle.adjacent[(shared_edge_vertex_index + 2) & 3] {
                        let opposite_adjacent1 = adjacent.clone();
                        if !adjacent_triangles_to_process.contains(opposite_adjacent1){
                        adjacent_triangles_to_process.push(opposite_adjacent1);
                        let neighbor_edge = self.get_shared_edge(triangle_set.get_triangle(opposite_adjacent1), triangle.adjacent[opposite_triangle_index].unwrap());
                        adjacent_triangle_edges.push(neighbor_edge);
                        }
                    }

                    if let Some(adjacent) = triangle.adjacent[not_in_edge_vertex_index] {
                        let triangle_adjacent0 = adjacent.clone();
                        if !adjacent_triangles_to_process.contains(&triangle_adjacent0){
                        adjacent_triangles_to_process.push(triangle_adjacent0);
                        let neighbor_edge = self.get_shared_edge(triangle_set.get_triangle(triangle_adjacent0), triangle.adjacent[current_triangle_to_swap].unwrap());
                        adjacent_triangle_edges.push(neighbor_edge);
                        }

                    }

                    if let Some(adjacent) = triangle.adjacent[(not_in_edge_vertex_index + 2) % 3]{
                        let triangle_adjacent1 = adjacent.clone();
                        if !adjacent_triangles_to_process.contains(&triangle_adjacent1){
                        adjacent_triangles_to_process.push(triangle_adjacent1);
                        let neighbor_edge = self.get_shared_edge(triangle_set.get_triangle(triangle_adjacent1), triangle.adjacent[current_triangle_to_swap].unwrap());
                        adjacent_triangle_edges.push(neighbor_edge);
                        }

                    }
                    
                    // 4.8: Swap edges
                    swap_edges(current_triangle_to_swap, triangle, not_in_edge_vertex_index, opposite_triangle, shared_edge_vertex_index);
                }
            }
        }

/// Finds the index of the edge (0 to 2) of a triangle that is shared with another triangle.
/// 
/// # Arguments
/// 
/// * `triangle` - The triangle whose edge is to be returned.
/// * `adjacent_triangle` - The index of the adjacent triangle.
/// 
/// # Returns
/// 
/// The index of the shared edge in the first triangle, from 0 to 2.
fn get_shared_edge(triangle: &DelaunayTriangle, adjacent_triangle: usize) -> Option<usize> {
    for shared_edge_vertex_local_index in 0..3 {
        if let Some(adjacent) = triangle.adjacent[shared_edge_vertex_local_index] {
            if adjacent == adjacent_triangle{
            return Some(shared_edge_vertex_local_index);
            }
        }
    }

    return None;
}

/// Given 2 adjacent triangles, it replaces the shared edge with a new edge that joins both opposite vertices. For example, triangles ABC-CBD would become ADC-ABD.
/// For the main triangle, its shared edge vertex is moved so the new shared edge vertex is 1 position behind / or 2 forward (if it was 1, now the shared edge is 0).
/// Parameters:
/// - main_triangle_index: The index of the main triangle.
/// - triangle: Data about the main triangle.
/// - not_in_edge_triangle_vertex: The local index of the vertex that is not in the shared edge, in the main triangle.
/// - opposite_triangle: Data about the triangle that opposes the main triangle.
/// - opposite_triangle_shared_edge_vertex_local_index: The local index of the vertex where the shared edge begins, in the opposite triangle.
fn swap_edges(&self, main_triangle_index: usize, main_triangle: DelaunayTriangle, not_in_edge_vertex_local_index: usize, opposite_triangle: &mut DelaunayTriangle, opposite_triangle_shared_edge_vertex_local_index: usize) {
    let opposite_vertex = (opposite_triangle_shared_edge_vertex_local_index + 2) % 3;

            //           2 _|_ a
            //       A2 _   |   _
            //       _      |      _
            //   0 _     A1 |         _  c (opposite vertex)
            //       _      |      _
            //          _   |   _
            //       A0   _ |_
            //              |
            //            1    b

            //           2 _|_ 
            //       A2 _       _ A1
            //       _             _
            //   0 _________A0_______ 1
            //   a   _             _  c
            //          _       _
            //             _ _
            //              | b
            //            

    // Only one vertex of each triangle is moved
    let opposite_triangle_index = main_triangle.adjacent[(not_in_edge_vertex_local_index + 1) % 3];
    main_triangle.p[(not_in_edge_vertex_local_index + 1) % 3] = opposite_triangle.p[opposite_vertex];
    opposite_triangle.p[opposite_triangle_shared_edge_vertex_local_index] = main_triangle.p[not_in_edge_vertex_local_index];
    opposite_triangle.adjacent[opposite_triangle_shared_edge_vertex_local_index] = main_triangle.adjacent[not_in_edge_vertex_local_index];
    main_triangle.adjacent[not_in_edge_vertex_local_index] = opposite_triangle_index;
    main_triangle.adjacent[(not_in_edge_vertex_local_index + 1) % 3] = opposite_triangle.adjacent[opposite_vertex];
    opposite_triangle.adjacent[opposite_vertex] = Some(main_triangle_index);

    let triangle_set = self.triangle_set.expect("There should be a triangle set at this point or this function has been called too early.");
    triangle_set.replace_triangle(main_triangle_index, main_triangle);
    triangle_set.replace_triangle(opposite_triangle_index, opposite_triangle);

    // Adjacent triangles are updated too
    if let Some(main_adjacent) = main_triangle.adjacent[(not_in_edge_vertex_local_index + 1) % 3]{
        triangle_set.replace_adjacent(main_adjacent, opposite_triangle_index, Some(main_triangle_index));
    }

    if let Some(opposite_adjacent) = opposite_triangle.adjacent[opposite_triangle_shared_edge_vertex_local_index]{
        triangle_set.replace_adjacent(opposite_adjacent, Some(main_triangle_index), opposite_triangle_index);
    }
}

/// Adds an edge to the triangulation in such a way that it keeps there even if it forms triangles that do not fulfill the Delaunay constraint.
/// If the edge already exists, nothing will be done.
/// The order in which the vertices of the edges are provided is important, as the edge may be part of a polygon whose vertices are sorted counterclockwise.
///
/// # Arguments
///
/// * `endpointAIndex` - The index of the first vertex of the edge, in the existing triangulation.
/// * `endpointBIndex` - The index of the second vertex of the edge, in the existing triangulation.
fn add_constrained_edge_to_triangulation(&self, endpoint_a_index: usize, endpoint_b_index: usize) {
    let triangle_set = self.triangle_set.unwrap();
            // Detects if the edge already exists
            if let Some(_) = triangle_set.find_triangle_that_contains_edge(endpoint_a_index, endpoint_b_index)
                {
                return;
            }

            let edge_endpoint_a = triangle_set.get_point_by_index(endpoint_a_index);
            let edge_endpoint_b = triangle_set.get_point_by_index(endpoint_b_index);

            // 5.3.1: Search for the triangle that contains the beginning of the new edge
            let triangle_containing_a = triangle_set.find_triangle_that_contains_line_endpoint(endpoint_a_index, endpoint_b_index);

            // 5.3.2: Get all the triangle edges intersected by the constrained edge
            let intersected_triangle_edges = Vec::<Edge>::new();
            triangle_set.get_intersecting_edges(edge_endpoint_a, edge_endpoint_b, triangle_containing_a, &mut intersected_triangle_edges);

            let new_edges = Vec::<DelaunayTriangleEdge>::new();

            while (intersected_triangle_edges.len() > 0){
                // wird eine copy erstellt?
                let current_intersected_triangle_edge = intersected_triangle_edges[intersected_triangle_edges.len() - 1];
                intersected_triangle_edges.remove(intersected_triangle_edges.len() -1);

                // 5.3.3: Form quadrilaterals and swap intersected edges
                // Deduces the data for both triangles
                if let Some(current_intersected_triangle_edge) = triangle_set.find_triangle_that_contains_edge(current_intersected_triangle_edge.edge_vertex_a, current_intersected_triangle_edge.edge_vertex_b){
                    let intersected_triangle = triangle_set.get_triangle(current_intersected_triangle_edge.triangle_index);
                    // TODO This should probably be checked for None, I think there are cases it is None.
                    let opposite_triangle = triangle_set.get_triangle(intersected_triangle.adjacent[current_intersected_triangle_edge.edge_index].unwrap());
                    let triangle_points = triangle_set.get_triangle_points(current_intersected_triangle_edge.triangle_index);

                // Gets the opposite vertex of adjacent triangle, knowing the fisrt vertex of the shared edge
                int oppositeVertex = NOT_FOUND;

                //List<int> debugP = intersectedTriangle.DebugP;
                //List<int> debugA = intersectedTriangle.DebugAdjacent;
                //List<int> debugP2 = oppositeTriangle.DebugP;
                //List<int> debugA2 = oppositeTriangle.DebugAdjacent;

                int oppositeSharedEdgeVertex = NOT_FOUND; // The first vertex in the shared edge of the opposite triangle

                for (int j = 0; j < 3; ++j)
                {
                    if (oppositeTriangle.p[j] == intersectedTriangle.p[(currentIntersectedTriangleEdge.EdgeIndex + 1) % 3]) // Comparing with the endpoint B of the edge, since the edge AB is BA in the adjacent triangle
                    {
                        oppositeVertex = oppositeTriangle.p[(j + 2) % 3];
                        oppositeSharedEdgeVertex = j;
                        break;
                    }
                }

                Vec2 oppositePoint = m_triangleSet.GetPointByIndex(oppositeVertex);

                if (MathUtils.IsQuadrilateralConvex(trianglePoints.p0, trianglePoints.p1, trianglePoints.p2, oppositePoint))
                {
                    // Swap
                    int notInEdgeTriangleVertex = (currentIntersectedTriangleEdge.EdgeIndex + 2) % 3;
                    SwapEdges(currentIntersectedTriangleEdge.TriangleIndex, intersectedTriangle, notInEdgeTriangleVertex, oppositeTriangle, oppositeSharedEdgeVertex);

                    // Refreshes triangle data after swapping
                    intersectedTriangle = m_triangleSet.GetTriangle(currentIntersectedTriangleEdge.TriangleIndex);

                    //oppositeTriangle = m_triangles.GetTriangle(intersectedTriangle.adjacent[(currentIntersectedTriangleEdge.EdgeIndex + 2) % 3]);
                    //debugP = intersectedTriangle.DebugP;
                    //debugA = intersectedTriangle.DebugAdjacent;
                    //debugP2 = oppositeTriangle.DebugP;
                    //debugA2 = oppositeTriangle.DebugAdjacent;

                    // Check new diagonal against the intersecting edge
                    Vec2 intersectionPoint;
                    int newTriangleSharedEdgeVertex = (currentIntersectedTriangleEdge.EdgeIndex + 2) % 3; // Read SwapEdges method to understand the +2
                    Vec2 newTriangleSharedEdgePointA = m_triangleSet.GetPointByIndex(intersectedTriangle.p[newTriangleSharedEdgeVertex]);
                    Vec2 newTriangleSharedEdgePointB = m_triangleSet.GetPointByIndex(intersectedTriangle.p[(newTriangleSharedEdgeVertex  + 1) % 3]);

                    DelaunayTriangleEdge newEdge = new DelaunayTriangleEdge(NOT_FOUND, NOT_FOUND, intersectedTriangle.p[newTriangleSharedEdgeVertex], intersectedTriangle.p[(newTriangleSharedEdgeVertex + 1) % 3]);

                    if (newTriangleSharedEdgePointA != edgeEndpointB && newTriangleSharedEdgePointB != edgeEndpointB && // Watch out! It thinks the line intersects with the edge when an endpoint coincides with a triangle vertex, this problem is avoided thanks to this conditions
                        newTriangleSharedEdgePointA != edgeEndpointA && newTriangleSharedEdgePointB != edgeEndpointA &&
                        MathUtils.IntersectionBetweenLines(edgeEndpointA, edgeEndpointB, newTriangleSharedEdgePointA, newTriangleSharedEdgePointB, out intersectionPoint))
                    {
                        // New triangles edge still intersects with the constrained edge, so it is returned to the list
                        intersectedTriangleEdges.Insert(0, newEdge);
                    }
                    else
                    {
                        newEdges.Add(newEdge);
                    }
                }
                else
                {
                    // Back to the list
                    intersectedTriangleEdges.Insert(0, currentIntersectedTriangleEdge);
                }
            }
            }

            // 5.3.4. Check Delaunay constraint and swap edges
            for (int i = 0; i < newEdges.Count; ++i)
            {
                // Checks if the constrained edge coincides with the new edge
                Vec2 triangleEdgePointA = m_triangleSet.GetPointByIndex(newEdges[i].EdgeVertexA);
                Vec2 triangleEdgePointB = m_triangleSet.GetPointByIndex(newEdges[i].EdgeVertexB);

                if ((triangleEdgePointA == edgeEndpointA && triangleEdgePointB == edgeEndpointB) ||
                    (triangleEdgePointB == edgeEndpointA && triangleEdgePointA == edgeEndpointB))
                {
                    continue;
                }

                // Deduces the data for both triangles
                DelaunayTriangleEdge currentEdge = m_triangleSet.FindTriangleThatContainsEdge(newEdges[i].EdgeVertexA, newEdges[i].EdgeVertexB);
                DelaunayTriangle currentEdgeTriangle = m_triangleSet.GetTriangle(currentEdge.TriangleIndex);
                int triangleVertexNotShared = (currentEdge.EdgeIndex + 2) % 3;
                Vec2 trianglePointNotShared = m_triangleSet.GetPointByIndex(currentEdgeTriangle.p[triangleVertexNotShared]);
                DelaunayTriangle oppositeTriangle = m_triangleSet.GetTriangle(currentEdgeTriangle.adjacent[currentEdge.EdgeIndex]);
                Triangle2D oppositeTrianglePoints = m_triangleSet.GetTrianglePoints(currentEdgeTriangle.adjacent[currentEdge.EdgeIndex]);

                //List<int> debugP = currentEdgeTriangle.DebugP;
                //List<int> debugA = currentEdgeTriangle.DebugAdjacent;
                //List<int> debugP2 = oppositeTriangle.DebugP;
                //List<int> debugA2 = oppositeTriangle.DebugAdjacent;

                if (MathUtils.IsPointInsideCircumcircle(oppositeTrianglePoints.p0, oppositeTrianglePoints.p1, oppositeTrianglePoints.p2, trianglePointNotShared))
                {
                    // Finds the edge of the opposite triangle that is shared with the other triangle, this edge will be swapped
                    int sharedEdgeVertexLocalIndex = 0;

                    for (; sharedEdgeVertexLocalIndex < 3; ++sharedEdgeVertexLocalIndex)
                    {
                        if (oppositeTriangle.adjacent[sharedEdgeVertexLocalIndex] == currentEdge.TriangleIndex)
                        {
                            break;
                        }
                    }

                    // Swap
                    SwapEdges(currentEdge.TriangleIndex, currentEdgeTriangle, triangleVertexNotShared, oppositeTriangle, sharedEdgeVertexLocalIndex);
                }
            }

            //Debug.DrawLine(edgeEndpointA, edgeEndpointB, Color.magenta, 10.0f);
        }
}